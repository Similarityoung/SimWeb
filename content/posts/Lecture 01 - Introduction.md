---
title: Lecture 01 - Introduction
tags:
  - distribute
categories:
  - MIT6.824
date: 2025-01-05T15:23:22+08:00
draft: true
---
### 1.1 分布式系统的驱动力和挑战（Drives and Challenges）

#### 驱动

人们使用大量的相互协作的计算机驱动力是：

- **更高的计算性能**，而（大量的计算机意味着）大量的并行运算，大量CPU、大量内存、以及大量磁盘在并行的运行。
    
- **提供容错**（fault tolerance），比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另一台。
    
- 一些问题天然在**空间上是分布的**。例如银行转账，我们假设银行A在纽约有一台服务器，银行B在伦敦有一台服务器，这就需要一种两者之间协调的方法。
    
- 人们构建分布式系**达成一些安全的目标**。比如有一些代码并不被信任，但是你又需要和它进行交互，这些代码不会立即表现的恶意或者出现 bug。你不会想要信任这些代码，所以你或许想要将代码分散在多处运行，这样你的代码在另一台计算机运行，我的代码在我的计算机上运行，我们通过一些特定的网络协议通信。所以，我们可能会担心安全问题，我们把系统分成多个的计算机，这样可以**限制出错域**。

#### 挑战

所有的这些分布式系统的问题（挑战）在于：

- 因为系统中存在很多部分，这些部分又在并发执行，你会遇到**并发编程**和各种**复杂交互**所带来的问题，以及**时间依赖**的问题（比如同步，异步）。
    
- 分布式系统有多个组成部分，再加上计算机网络，你会会遇到一些意想不到的故障。如果你只有一台计算机，那么它通常要么是工作，要么是故障或者没电，总的来说，要么是在工作，要么是没有工作。而由多台计算机组成的分布式系统，可能会有一部分组件在工作，而另一部分组件停止运行，或者这些计算机都在正常运行，但是网络中断了或者不稳定。所以，**局部错误**也是分布式系统很难的原因。
    
- 最后一个导致分布式系统很难的原因是，人们设计分布式系统的根本原因通常是为了获得更高的性能，比如说一千台计算机或者一千个磁盘臂达到的性能。但是实际上一千台机器到底有多少性能是一个棘手的问题，这里有很多难点。所以通常需要倍加小心地设计才能让系统实际达到你期望的性能。（如何设计以获取更高的性能）

### 1.2 课程结构（Course Structure）

阅读论文 完成四个 `lab`，并通过测试

### 1.3 分布式系统的抽象和实现工具（Abstraction and Implementation）

基础架构的类型主要是存储 `storage` ，通信（网络） `comms.` 和计算 `comp.` 。

`存储`，这是一个定义明确且有用的抽象概念。人们知道如何构建和使用储存系统，知道如何去构建一种多副本，容错的，高性能分布式存储实现。

随着课程的进行，我们会知道，很难能找到一个抽象来描述分布式的存储或者计算，使得它们能够像非分布式系统一样有简单易懂的接口。但是，人们在这方面的做的越来越好，我们会尝试学习人们在构建这样的抽象时的一些收获。(在分布式系统中用单体应用的方式来开发)

当我们在考虑这些抽象的时候，第一个出现的话题就是实现。人们在构建分布系统时，使用了很多的工具，例如：

- `RPC`（Remote Procedure Call）。RPC的目标就是掩盖我们正在不可靠网络上通信的事实。
    
- `线程` 是一种编程技术，使得我们可以利用多核心计算机。对于本课程而言，更重要的是，线程提供了一种`结构化的并发操作方式`，这样，从程序员角度来说可以简化并发操作。
    
- 考虑并发控制，比如`锁`。

### 1.4 可扩展性（Scalability）

`可扩展性`指的是，如果我用一台计算机解决了一些问题，当我买了第二台计算机，我只需要一半的时间就可以解决这些问题，或者说每分钟可以解决两倍数量的问题。两台计算机构成的系统如果有两倍性能或者吞吐.

### 1.5 可用性（Availability）

大型分布式系统中有一个大问题，那就是一些**很罕见的问题会被放大**。

例如在我们的1000台计算机的集群中，总是有故障，要么是机器故障，要么是运行出错，要么是运行缓慢，要么是执行错误的任务。一个更常见的问题是网络，在一个有1000台计算机的网络中，会有大量的网络电缆和网络交换机，所以总是会有人踩着网线导致网线从接口掉出，或者交换机风扇故障导致交换机过热而不工作。在一个大规模分布式系统中，各个地方总是有一些小问题出现。所以大规模系统会将一些几乎不可能并且你不需要考虑的问题，变成一个持续不断的问题。

**因为错误总会发生，必须要在设计时就考虑，系统能够屏蔽错误或者说能够在出错时继续运行。**

同时，因为我们需要为第三方应用开发人员提供方便的抽象接口，我们的确也需要构建这样一种基础架构，它能够尽可能多的**对应用开发人员屏蔽和掩盖错误**。这样，应用开发人员就不需要处理各种各样的可能发生的错误。

对于容错，有很多不同的概念可以表述。这些表述中，有一个共同的思想就是可用性（Availability）。某些系统经过精心的设计，这样在特定的错误类型下，系统仍然能够正常运行，仍然可以像没有出现错误一样，为你提供完整的服务。

### 1.6 一致性（Consistency）

实际上，对于一致性有很多不同的定义。有一些非常直观，比如说 `get` 请求可以得到最近一次完成的 `put` 请求写入的值。这种一般也被称为`强一致`（Strong Consistency）。

`弱一致`是指，不保证 `get` 请求可以得到最近一次完成的 `put` 请求写入的值。尽管有很多细节的工作要处理.

强一致可以保证 `get` 得到的是 `put` 写入的最新的数据；而很多的弱一致系统不会做出类似的保证。所以在一个弱一致系统中，某人通过 `put` 请求写入了一个数据，但是你通过 `get` 看到的可能仍然是一个旧数据，而这个旧数据可能是很久之前写入的。

人们对于弱一致感兴趣的原因是，虽然强一致可以确保get获取的是最新的数据，但是实现这一点的**代价非常高**。几乎可以确定的是，分布式系统的各个组件需要做大量的通信，才能实现强一致性。所以，为了尽可能的避免通信，尤其当副本相隔的很远的时候，人们会构建弱一致系统，并允许读取出旧的数据。当然，为了让弱一致更有实际意义，人们还会定义更多的规则。

### 1.7 `MapReduce` 基本工作方式

`MapReduce` 的思想是，应用程序设计人员和分布式运算的使用者，只需要写简单的 `Map` 函数和 `Reduce` 函数，而不需要知道任何有关分布式的事情， `MapReduce` 框架会处理剩下的事情。

