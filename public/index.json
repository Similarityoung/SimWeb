[{"content":"JavaScript 教程 在 HTML 中，JavaScript 代码必须位于标签之间。\n能够在 HTML 文档中放置任意数量的脚本。\n脚本可被放置与 HTML 页面的 \u0026lt;body\u0026gt; 或 \u0026lt;head\u0026gt; 部分中，或兼而有之。\n\u0026lt;script src=\u0026#34;myScript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意是 src是引用 js 的方式。\n通过 const 定义的变量与 let 变量类似，但==不能重新赋值。==\n模板字面量_提供了一种将变量和表达式插入字符串的简单方法\u0026ndash;${...}\n箭头函数 hello = () =\u0026gt; { return \u0026#34;Hello World!\u0026#34;; } 模块（modules） 导出 JavaScript 模块允许您将代码分解成单独的文件。\n这会使维护代码库更加容易。\n模块是使用 import 语句从外部文件导入的。\n模块还依赖于 \u0026lt; script \u0026gt; 标签中的 type=\u0026quot;module\u0026quot;。\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import message from \u0026#34;./message.js\u0026#34;; \u0026lt;/script\u0026gt; 命名导出（Named Exports） 让我们创建一个名为 person.js 的文件，并在其中填充我们要导出的内容。\n您可以通过两种方式创建命名导出。一种是逐个内联创建，另一种是在文件底部一次性全部创建。\n逐个内联创建：\nperson.js\nexport const name = \u0026#34;Bill\u0026#34;; export const age = 19; 在文件底部一次性创建：\nperson.js\nconst name = \u0026#34;Bill\u0026#34;; const age = 19; export {name, age}; 默认导出（Default Exports） 让我们创建另一个名为 message.js 的文件，并用其演示默认导出。\n一个文件中只能有一个默认导出。\nmessage.js\nconst message = () =\u0026gt; { const name = \u0026#34;Bill\u0026#34;; const age = 19; return name + \u0026#39; is \u0026#39; + age + \u0026#39;years old.\u0026#39;; }; export default message; 导入 您可以通过两种方式将模块导入到文件中，具体取决于它们是命名导出还是默认导出。\n命名导出是使用大括号构造的。默认导出不是。\n从命名导出中导入 从文件 person.js 导入命名导出：\nimport { name, age } from \u0026#34;./person.js\u0026#34;; 从默认导出导入 从文件message.js导入默认导出：\nimport message from \u0026#34;./message.js\u0026#34;; JavaScript 性能优化 减少循环中的活动\n减少 DOM 访问\n缩减 DOM 规模\n避免不必要的变量\n延迟 JavaScript 加载\n避免使用 with\n执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境。\n每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立且独一无二的。当函数执行完毕，它所产生的执行期上下文会被销毁。\n参考链接：https://www.cnblogs.com/chenyingjie1207/p/9966036.html\nJavaScript 对象 set JavaScript 的 Set（集合）是一组唯一值的集合。\n每个值只能在 Set 中出现一次。\nSet 可以容纳任何数据类型的值。\nmap Map 保存键值对，其中键可以是任何数据类型。\nMap 会记住键的原始插入顺序。\nMap 提供表示映射大小的属性。\nJavaScript 函数 参数规则 JavaScript 函数定义不会为参数（parameter）规定数据类型。\nJavaScript 函数不会对所传递的参数（argument）实行类型检查。\nJavaScript 函数不会检查所接收参数（argument）的数量。\n参数通过值传递 函数调用中的参数（parameter）是函数的参数（argument）。\nJavaScript 参数通过_值_传递：函数只知道值，而不是参数的位置。\n如果函数改变了参数的值，它不会改变参数的原始值。\n参数的改变在函数之外是不可见的。\n对象是由引用传递的 在 JavaScript 中，对象引用是值。\n正因如此，对象的行为就像它们通过_引用_来传递：\n如果函数改变了对象属性，它也改变了原始值。\n对象属性的改变在函数之外是可见的。\nthis 指向 解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是 this，this 指向的是一个对象，这个对象我们称为函数执行的 上下文对象。\n函数内 this 的指向【非常重要】 我们在《JavaScript 基础/函数.md》这篇文章讲过，函数的调用有六种形式。\n在ES5语法中，根据函数的调用方式的不同，this 会指向不同的对象：\n1、以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如fun();相当于window.fun();\n2、以方法的形式调用时，this 指向调用方法的那个对象\n3、以构造函数的形式调用时，this 指向实例对象\n4、以事件绑定函数的形式调用时，this 指向绑定事件的对象\n5、使用 call 和 apply 调用时，this 指向指定的那个对象\n第 1 条的举例：\nfunction fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以函数形式调用，this是window fun(); //可以理解成 window.fun() 打印结果：\nWindow 全局的name属性 上面的举例可以看出，this 指向的是 window 对象，所以 this.name 指的是全局的 name。\n第 2 条的举例：\nfunction fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以方法的形式调用，this是调用方法的对象 obj2.sayName(); 打印结果：\nObject vae 上面的举例可以看出，this 指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。\nES6 箭头函数中 this 的指向 ES6 中的箭头函数并不使用上面的准则，而是会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。\n改变函数内部的 this 指向 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。常见的方法有 call()、apply()、bind() 方法。继续往下看。\ncall() 方法 call() 方法的作用 call() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\ncall() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。\n语法：\nfn1.call(想要将this指向哪里, 函数实参1, 函数实参2); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\ncall() 方法举例 举例 1、通过 call() 调用函数：\nconst obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1() { console.log(this); console.log(this.nickName); } fn1.call(this); // this的指向并没有被改变，此时相当于 fn1(); 上方代码的打印结果：\nwindow undefined 上面的代码，跟普通的函数调用 fn1() 没有区别。\n举例 2、通过 call() 改变 this 指向：\nvar obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a, b) { console.log(this); console.log(this.nickName); console.log(a + b); } fn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数 上方代码的打印结果：\nobj1 qianguyihao 6 举例 3、通过 call() 实现继承：\n// 给 Father 增加 name 和 age 属性 function Father(myName, myAge) { this.name = myName; this.age = myAge; } function Son(myName, myAge) { // 【下面这一行，重要代码】 // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge); } const son1 = new Son(\u0026#39;千古壹号\u0026#39;, 28); console.log(JSON.stringify(son1)); 上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n打印结果：\n{\u0026#34;myName\u0026#34;:\u0026#34;千古壹号\u0026#34;,\u0026#34;myAge\u0026#34;:28} apply() 方法 apply() 方法的作用 apply() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n语法：\nfn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n到这里可以看出， call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者伪数组）。\napply() 方法举例 举例、通过 apply() 改变 this 指向：\nvar obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a) { console.log(this); console.log(this.nickName); console.log(a); } fn1.apply(obj1, [\u0026#39;hello\u0026#39;]); // 先将 this 指向 obj1，然后执行 fn1() 函数 注意，上方代码中，apply() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n打印结果：\nobj1 qianguyihao hello apply() 方法的巧妙应用：求数组的最大值 我们知道，如果想要求数组中元素的最大值，数组本身是没有自带方法的。那怎么办呢？\n虽然数组里没有获取最大值的方法，但是数值里有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，传的刚好是数组，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n举例：求数组中多个元素的最大值：\nconst arr1 = [3, 7, 10, 8]; // 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。 const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值 console.log(maxValue); const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值 console.log(minValue); 打印结果：\n10 3 bind() 方法 bind() 方法的作用 bind() 方法不会调用函数，但是可以改变函数内部的 this 指向。\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n语法：\n新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2); 参数：\n第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n其他参数：fn1 函数的实参。\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。\n闭包 闭包（closure）的概念 闭包：如果外部作用域有权访问另外一个函数内部的局部变量时，那就产生了闭包。这个内部函数称之为闭包函数。注意，这里强调的是访问局部变量。\nJavaScript 变量属于本地或全局作用域。\n**全局变量能够通过闭包实现局部（私有）。\nJavaScript 类 js 的类并不是对象，它是 js ==对象的模板==。\n如需创建类继承，请使用 extends 关键字。 // 感觉这个和 java 很像了\n==static== 关键字也和 java 用法类似\n回调函数 [!NOTE] 简介 \u0026ldquo;I will call back later!\u0026rdquo;\n回调 (callback) 是作为==参数传递给另一个函数的函数==\n这种技术允许函数调用另一个函数\n回调函数可以在另一个函数完成后运行\n==将函数作为入参，只要函数名称即可，不用加其他任何东西==\n通过回调使用异步js 实例 setTimeout(myFunction, 3000); function myFunction() { document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = \u0026#34;I love You !!\u0026#34;; } // 使用回调函数调用myFunction，setTimeout第一个参数是回调函数，第二个参数是多少毫秒后执行 等待文件 如果您创建函数来加载外部资源（如脚本或文件），则在内容完全加载之前无法使用这些内容。这是使用回调的最佳时机。\nfunction myDisplayer(some) { document.getElementById(\u0026#34;demo\u0026#34;).innerHTML = some; } function getFile(myCallback) { let req = new XMLHttpRequest(); req.open(\u0026#39;GET\u0026#39;, \u0026#34;mycar.html\u0026#34;); req.onload = function() { if (req.status == 200) { myCallback(this.responseText); } else { myCallback(\u0026#34;Error: \u0026#34; + req.status); } } req.send(); } getFile(myDisplayer); JavaScript Promise [!NOTE] 简介\n\u0026ldquo;I Promise a Result!\u0026rdquo;\n\u0026ldquo;Producing code（生产代码）\u0026rdquo; 是需要一些时间的代码\n\u0026ldquo;Consuming code（消费代码）\u0026rdquo; 是必须等待结果的代码\nPromise 是一个 JavaScript 对象，它链接生成代码和消费代码\nJavaScript Promise 对象包含生产代码和对消费代码的调用：\nlet myPromise = new Promise(function(myResolve, myReject) { // \u0026#34;Producing Code\u0026#34;（可能需要一些时间） myResolve(); // 成功时 myReject(); // 出错时 }); // \u0026#34;Consuming Code\u0026#34; （必须等待一个兑现的承诺） myPromise.then( function(value) { /* 成功时的代码 */ }, function(error) { /* 出错时的代码 */ } ); JavaScript Async [!NOTE] \u0026ldquo;async and await make promises easier to write\u0026rdquo;\nasync 使函数返回 Promise\nawait 使函数等待 Promise\n函数前的关键字 async 使函数返回 promise：\nasync function myFunction() { return \u0026#34;Hello\u0026#34;; } // 等同于： async function myFunction() { return Promise.resolve(\u0026#34;Hello\u0026#34;); } 函数前的关键字 await 使函数等待 promise，我的理解是替代 promise 中的.then 后的函数，不用考虑对错的不同处理结果。\n``let value = await promise;\nJavaScrip Html DOM 通过 HTML DOM，JavaScript 能够访问和改变 HTML 文档的所有元素。\n对象的 HTML DOM 树 JavaScript 能改变页面中的所有 HTML 元素 JavaScript 能改变页面中的所有 HTML 属性 JavaScript 能改变页面中的所有 CSS 样式 JavaScript 能删除已有的 HTML 元素和属性 JavaScript 能添加新的 HTML 元素和属性 JavaScript 能对页面中所有已有的 HTML 事件作出反应 JavaScript 能在页面中创建新的 HTML 事件 JavaScript HTML DOM 动画 function myMove() { var elem = document.getElementById(\u0026#34;animate\u0026#34;); var pos = 0; var id = setInterval(frame, 5); function frame() { if (pos == 350) { clearInterval(id); } else { pos++; elem.style.top = pos + \u0026#34;px\u0026#34;; elem.style.left = pos + \u0026#34;px\u0026#34;; } } } JavaScript HTML DOM 事件 onmouseover 和 onmouseout 事件可用于当用户将鼠标移至 HTML 元素上或移出时触发某个函数\nonmousedown, onmouseup 以及 onclick 事件构成了完整的鼠标点击事件。\n首先当鼠标按钮被点击时，onmousedown 事件被触发；然后当鼠标按钮被释放时，onmouseup 事件被触发；最后，当鼠标点击完成后，onclick 事件被触发。\nvar x = document.getElementById(\u0026#34;myBtn\u0026#34;); x.addEventListener(\u0026#34;mouseover\u0026#34;, myFunction); x.addEventListener(\u0026#34;click\u0026#34;, mySecondFunction); x.addEventListener(\u0026#34;mouseout\u0026#34;, myThirdFunction); JavaScript API 约束验证 DOM 方法 属性 描述 checkValidity() 如果 input 元素包含有效数据，则返回 true。 setCustomValidity() 设置 input 元素的 validationMessage 属性。 约束验证 DOM 属性 属性 描述 validity 包含与输入元素有效性相关的布尔属性。 validationMessage 包含当有效性为 false 时浏览器将显示的消息。 willValidate 指示是否将验证 input 元素。 AJAX 简介 AJAX 是开发者的梦想，因为您能够：\n不刷新页面更新网页 在页面加载后从服务器请求数据 在页面加载后从服务器接收数据 在后台向服务器发送数据 什么是 AJAX？ AJAX = ==A==synchronous ==J==avaScript ==A==nd ==X==ML.\nAJAX 并非编程语言。\nAJAX 仅仅组合了：\n浏览器内建的 XMLHttpRequest 对象（从 web 服务器请求数据） JavaScript 和 HTML DOM（显示或使用数据） Ajax 是一个令人误导的名称。Ajax 应用程序可能使用 XML 来传输数据，但将数据作为纯文本或 JSON 文本传输也同样常见。\nAjax 允许通过与场景后面的 Web 服务器交换数据来异步更新网页。这意味着可以更新网页的部分，而不需要重新加载整个页面。\nAJAX 如何工作 网页中发生一个事件（页面加载、按钮点击） 由 JavaScript 创建 XMLHttpRequest 对象 XMLHttpRequest 对象向 web 服务器发送请求 服务器处理该请求 服务器将响应发送回网页 由 JavaScript 读取响应 由 JavaScript 执行正确的动作（比如更新页面） AJAX - XMLHttpRequest 对象 XMLHttpRequest 对象是 AJAX 的基石。\n创建 XMLHttpRequest 对象 定义回调函数 打开 XMLHttpRequest 对象 向服务器发送请求 // 创建 XMLHttpRequest 对象 variable = new XMLHttpRequest(); // 定义回调函数 xhttp.onload = function() { // 当响应准备就绪时要做什么 } // 发送请求 // 如需向服务器发送请求，您可以使用 XMLHttpRequest 对象的 open() 和 send() 方法 xhttp.open(\u0026#34;GET\u0026#34;, \u0026#34;ajax_info.txt\u0026#34;); xhttp.send(); JSON JSON 简介 JSON: ==J==ava==S==cript ==O==bject ==N==otation（JavaScript 对象标记法）。\nJSON 是一种存储和交换数据的语法。\nJSON 是通过 JavaScript 对象标记法书写的文本。\n通过 JSON.parse() 解析数据，这些数据会成为 JavaScript 对象。\n通过 JSON.stringify() 把 JavaScript 对象转换为字符串。\njQuery DOM 选择器 都有 JavaScript 语法与其对应，以后再说\n","permalink":"https://sim-web.vercel.app/posts/3.-javascript/","summary":"JavaScript 教程 在 HTML 中，JavaScript 代码必须位于标签之间。\n能够在 HTML 文档中放置任意数量的脚本。\n脚本可被放置与 HTML 页面的 \u0026lt;body\u0026gt; 或 \u0026lt;head\u0026gt; 部分中，或兼而有之。\n\u0026lt;script src=\u0026#34;myScript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意是 src是引用 js 的方式。\n通过 const 定义的变量与 let 变量类似，但==不能重新赋值。==\n模板字面量_提供了一种将变量和表达式插入字符串的简单方法\u0026ndash;${...}\n箭头函数 hello = () =\u0026gt; { return \u0026#34;Hello World!\u0026#34;; } 模块（modules） 导出 JavaScript 模块允许您将代码分解成单独的文件。\n这会使维护代码库更加容易。\n模块是使用 import 语句从外部文件导入的。\n模块还依赖于 \u0026lt; script \u0026gt; 标签中的 type=\u0026quot;module\u0026quot;。\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import message from \u0026#34;./message.js\u0026#34;; \u0026lt;/script\u0026gt; 命名导出（Named Exports） 让我们创建一个名为 person.js 的文件，并在其中填充我们要导出的内容。\n您可以通过两种方式创建命名导出。一种是逐个内联创建，另一种是在文件底部一次性全部创建。\n逐个内联创建：\nperson.js\nexport const name = \u0026#34;Bill\u0026#34;; export const age = 19; 在文件底部一次性创建：","title":"JavaScript"},{"content":"字体属性的说明 （1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置：\nfont-family: \u0026#34;华文彩云\u0026#34;; 上方代码中，如果用户的 Windows 电脑里面没有这个字体，那么就会变成宋体。\n页面中，中文我们一般使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要单独安装字体，或者切图。\n（2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，提供备选字体。如下：（可以备选多个）\nfont-family: \u0026#34;微软雅黑\u0026#34;,\u0026#34;宋体\u0026#34;; 上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。\n（3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体：\nfont-family: \u0026#34;Times New Roman\u0026#34;,\u0026#34;微软雅黑\u0026#34;,\u0026#34;宋体\u0026#34;; 上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于smyhvae哈哈哈这段文字，smyhvae会采用Times New Roman字体，而哈哈哈会采用微软雅黑字体。\nCSS 整体感知 我们先来看一段简单的 css 代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { color: red; font-size: 30px; text-decoration: underline; font-weight: bold; text-align: center; font-style: italic; } h1 { color: blue; font-size: 50px; font-weight: bold; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;我是大标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;我是内容\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 解释如下：\n我们写 css 的地方是 style 标签，就是“样式”的意思，写在 head 里面。后面的课程中我们将知道，css 也可以写在单独的文件里面，现在我们先写在 style 标签里面。\n如果在 sublime 中输入\u0026lt;st或者\u0026lt;style然后按 tab 键，可以自动生成的格式如下：（建议）\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; type 表示“类型”，text 就是“纯文本”，css 也是纯文本。\n但是，如果在 sublime 中输入st或者style然后按 tab 键，可以自动生成的格式如下：（不建议）\n\u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; css 对换行不敏感，对空格也不敏感。但是一定要有标准的语法。冒号，分号都不能省略。\n基本选择器 标签选择器：针对一类标签 p{ font-size:14px; } ID 选择器：针对某一个特定的标签使用 #mytitle{ border:3px dashed green; } /*不建议使用*/ 类选择器：针对你想要的所有标签使用 .one{ width:800px; } 通用选择器（通配符）：针对所有的标签都适用（不建议使用） * { margin-left: 0px; margin-top: 0px; } 高级选择器 后代选择器 定义的时候用空格隔开 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .div1 p { color: red; } \u0026lt;/style\u0026gt; 交集选择器 定义的时候紧密相连 h3.special { color: red; } 并集选择器 定义的时候用逗号隔开，三种基本选择器都可以放进来。 p,h1,.title1,#one { color: red; } 静态伪类选择器、动态伪类选择器 伪类选择器分为两种。\n静态伪类：只能用于超链接的样式 :link 超链接点击之前\n:visited 链接被访问过之后\nPS：以上两种样式，只能用于超链接。\n动态伪类：针对所有标签都适用的样式 :hover “悬停”：鼠标放到标签上的时候\n:active “激活”： 鼠标点击标签，但是不松手时。\n:focus 是某个标签获得焦点时的样式（比如某个输入框获得焦点）\n超链接的四种状态 a标签有4种伪类（即对应四种状态），要求背诵。如下：\n:link “链接”：超链接点击之前 :visited “访问过的”：链接被访问过之后 :hover “悬停”：鼠标放到标签上的时候 :active “激活”： 鼠标点击标签，但是不松手时。 必须按照顺序书写，在写a:link、a:visited这两个伪类的时候，要么同时写，要么同时不写。如果只写a属性和a:link属性，不规范。\nCSS动画 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { width: 100px; height: 100px; margin: 100px; background-color: red; /* 调用动画*/ /* animation: 动画名称 持续时间 执行次数 是否反向 运动曲线 延迟执行。infinite 表示无限次*/ /*animation: move 1s alternate linear 3;*/ animation: move2 4s; } /* 方式一：定义一组动画*/ @keyframes move1 { from { transform: translateX(0px) rotate(0deg); } to { transform: translateX(500px) rotate(555deg); } } /* 方式二：定义多组动画*/ @keyframes move2 { 0% { transform: translateX(0px) translateY(0px); background-color: red; border-radius: 0; } 25% { transform: translateX(500px) translateY(0px); } /*动画执行到 50% 的时候，背景色变成绿色，形状变成圆形*/ 50% { /* 虽然两个方向都有translate，但其实只是Y轴上移动了200px。 因为X轴的500px是相对最开始的原点来说的。可以理解成此时的 translateX 是保存了之前的位移 */ transform: translateX(500px) translateY(200px); background-color: green; border-radius: 50%; } 75% { transform: translateX(0px) translateY(200px); } /*动画执行到 100% 的时候，背景色还原为红色，形状还原为正方形*/ 100% { /*坐标归零，表示回到原点。*/ transform: translateX(0px) translateY(0px); background-color: red; border-radius: 0; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 好用吗\n","permalink":"https://sim-web.vercel.app/posts/2.-css/","summary":"字体属性的说明 （1）网页中不是所有字体都能用，因为这个字体要看用户的电脑里面装没装，比如你设置：\nfont-family: \u0026#34;华文彩云\u0026#34;; 上方代码中，如果用户的 Windows 电脑里面没有这个字体，那么就会变成宋体。\n页面中，中文我们一般使用：微软雅黑、宋体、黑体。英文使用：Arial、Times New Roman。页面中如果需要其他的字体，就需要单独安装字体，或者切图。\n（2）为了防止用户电脑里，没有微软雅黑这个字体。就要用英语的逗号，提供备选字体。如下：（可以备选多个）\nfont-family: \u0026#34;微软雅黑\u0026#34;,\u0026#34;宋体\u0026#34;; 上方代码表示：如果用户电脑里没有安装微软雅黑字体，那么就是宋体。\n（3）我们须将英语字体放在最前面，这样所有的中文，就不能匹配英语字体，就自动的变为后面的中文字体：\nfont-family: \u0026#34;Times New Roman\u0026#34;,\u0026#34;微软雅黑\u0026#34;,\u0026#34;宋体\u0026#34;; 上方代码的意思是，英文会采用Times New Roman字体，而中文会采用微软雅黑字体（因为美国人设计的Times New Roman字体并不针对中文，所以中文会采用后面的微软雅黑）。比如说，对于smyhvae哈哈哈这段文字，smyhvae会采用Times New Roman字体，而哈哈哈会采用微软雅黑字体。\nCSS 整体感知 我们先来看一段简单的 css 代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; p { color: red; font-size: 30px; text-decoration: underline; font-weight: bold; text-align: center; font-style: italic; } h1 { color: blue; font-size: 50px; font-weight: bold; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;我是大标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;我是内容\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 解释如下：","title":"CSS"},{"content":"div和span的区别 \u0026lt;span\u0026gt;和\u0026lt;div\u0026gt;唯一的区别在于：\u0026lt;span\u0026gt;是不换行的，而\u0026lt;div\u0026gt;是换行的。\n如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。\ndiv在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。 div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。\nspan也是表达“小区域、小跨度”的标签，但只是一个文本级的标签。 就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。\nspan举例 \u0026lt;p\u0026gt; 简介简介简介简介简介简介简介简介 \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;详细信息\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;购买\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; div举例 \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;logo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;guanggao\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;dongxi\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 我们亲切地称这种模式叫做“div+css”：div标签负责布局、结构、分块，css负责样式。\n表格标签 表格标签用\u0026lt;table\u0026gt;表示。 一个表格\u0026lt;table\u0026gt;是由每行\u0026lt;tr\u0026gt;组成的，每行是由每个单元格\u0026lt;td\u0026gt;组成的。 所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。 在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。\n\u0026lt;table\u0026gt;属性 border：边框。像素为单位。\nstyle=\u0026quot;border-collapse:collapse;\u0026quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条）\nwidth：宽度。像素为单位。\nheight：高度。像素为单位。\nbordercolor：表格的边框颜色。\nalign：表格的水平对齐方式。属性值可以填：left right center。 注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签\u0026lt;td\u0026gt;进行设置）\ncellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。 注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=\u0026quot;rtl\u0026quot;，那就指的是内容到右边那条线的距离。\ncellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\nbgcolor=\u0026quot;#99cc66\u0026quot;：表格的背景颜色。\nbackground=\u0026quot;路径src/...\u0026quot;：背景图片。 背景图片的优先级大于背景颜色。\nbordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色\nbordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色 这两个属性的目的是为了设置3D的效果。\ndir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left） 既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。\n\u0026lt;tr\u0026gt;行 一个表格就是一行一行组成的。\n属性：\ndir：公有属性，设置这一行单元格内容的排列方式。可以取值：\nltr：从左到右（left to right，默认） rtl：从右到左（right to left） bgcolor：设置这一行的单元格的背景色。 注：没有background属性，即：无法设置这一行的背景图片，如果非要设置，可以用css实现。\nheight：一行的高度\nalign=\u0026quot;center\u0026quot;：一行的内容水平居中显示，取值：left、center、right\nvalign=\u0026quot;center\u0026quot;：一行的内容垂直居中，取值：top、middle、bottom\n\u0026lt;td\u0026gt;单元格 属性：\nalign：内容的横向对齐方式。属性值可以填：left right center。如果想让每个单元格的内容都居中，这个属性太麻烦了，以后用css来解决。\nvalign：内容的纵向对齐方式。属性值可以填：top middle bottom\nwidth：绝对值或者相对值(%)\nheight：单元格的高度\nbgcolor：设置这个单元格的背景色。\nbackground：设置这个单元格的背景图片。\n单元格的合并 单元格的属性：\ncolspan：横向合并。例如colspan=\u0026quot;2\u0026quot;表示当前单元格在水平方向上要占据两个单元格的位置。\nrowspan：纵向合并。例如rowspan=\u0026quot;2\u0026quot;表示当前单元格在垂直方向上要占据两个单元格的位置。\n框架标签 如果我们希望在一个网页中显示多个页面，那框架标签就派上用场了。\n注意，框架标签不能放在\u0026lt;body\u0026gt;标签里面，因为\u0026lt;body\u0026gt;标签代表的只是一个页面，而框架标签代表的是多个页面。于是：\u0026lt;frameset\u0026gt;和\u0026lt;body\u0026gt;只能二选一。 框架的集合用\u0026lt;frameset\u0026gt;表示，然后在\u0026lt;frameset\u0026gt;集合里放入一个一个的框架\u0026lt;frame\u0026gt; 补充：frameset和frame已经从 Web标准中删除，建议使用 iframe 代替。\n内嵌框架 内嵌框架用\u0026lt;iframe\u0026gt;表示。\u0026lt;iframe\u0026gt;是\u0026lt;body\u0026gt;的子标记。\n内嵌框架inner frame：嵌入在一个页面上的框架(仅仅IE、新版google浏览器支持，可能有其他浏览器也支持，暂时我不清楚)。\n属性：\nsrc=\u0026quot;subframe/the_second.html\u0026quot;：内嵌的那个页面 width=800：宽度 height=“150：高度 scrolling=\u0026quot;no\u0026quot;：是否需要滚动条。默认值是true。 name=\u0026quot;mainFrame\u0026quot;：窗口名称。公有属性。 标准的div+css页面，只会用到种类很少的标签：\ndiv p h1 span a img ul ol dl input 知道每个标签的特殊用法、属性。比如a标签，img的属性\n","permalink":"https://sim-web.vercel.app/posts/1.-html/","summary":"div和span的区别 \u0026lt;span\u0026gt;和\u0026lt;div\u0026gt;唯一的区别在于：\u0026lt;span\u0026gt;是不换行的，而\u0026lt;div\u0026gt;是换行的。\n如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。\ndiv在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。 div标签是一个容器级标签，里面什么都能放，甚至可以放div自己。\nspan也是表达“小区域、小跨度”的标签，但只是一个文本级的标签。 就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。\nspan举例 \u0026lt;p\u0026gt; 简介简介简介简介简介简介简介简介 \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;详细信息\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;购买\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; div举例 \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;logo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;guanggao\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;dongxi\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 我们亲切地称这种模式叫做“div+css”：div标签负责布局、结构、分块，css负责样式。\n表格标签 表格标签用\u0026lt;table\u0026gt;表示。 一个表格\u0026lt;table\u0026gt;是由每行\u0026lt;tr\u0026gt;组成的，每行是由每个单元格\u0026lt;td\u0026gt;组成的。 所以我们要记住，一个表格是由行组成的（行是由列组成的），而不是由行和列组成的。 在以前，要想固定标签的位置，唯一的方法就是表格。现在可以通过CSS定位的功能来实现。但是现在在做页面的时候，表格作用还是有一些的。\n\u0026lt;table\u0026gt;属性 border：边框。像素为单位。\nstyle=\u0026quot;border-collapse:collapse;\u0026quot;：单元格的线和表格的边框线合并（表格的两边框合并为一条）\nwidth：宽度。像素为单位。\nheight：高度。像素为单位。\nbordercolor：表格的边框颜色。\nalign：表格的水平对齐方式。属性值可以填：left right center。 注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签\u0026lt;td\u0026gt;进行设置）\ncellpadding：单元格内容到边的距离，像素为单位。默认情况下，文字是紧挨着左边那条线的，即默认情况下的值为0。 注意不是单元格内容到四条边的距离哈，而是到一条边的距离，默认是与左边那条线的距离。如果设置属性dir=\u0026quot;rtl\u0026quot;，那就指的是内容到右边那条线的距离。\ncellspacing：单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\nbgcolor=\u0026quot;#99cc66\u0026quot;：表格的背景颜色。\nbackground=\u0026quot;路径src/...\u0026quot;：背景图片。 背景图片的优先级大于背景颜色。\nbordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色\nbordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色 这两个属性的目的是为了设置3D的效果。\ndir：公有属性，单元格内容的排列方式(direction)。 可以 取值：ltr：从左到右（left to right，默认），rtl：从右到左（right to left） 既然说dir是共有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。\n\u0026lt;tr\u0026gt;行 一个表格就是一行一行组成的。","title":"HTML"}]